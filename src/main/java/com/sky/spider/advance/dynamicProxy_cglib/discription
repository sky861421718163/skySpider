本例是使用 cglib的动态代理

jdk动态代理是由java内部的反射机制来实现的，
cglib动态代理底层则是借助asm来实现的。

总的来说，反射机制在生成类的过程中比较高效，
而asm在生成类之后的相关执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。
还有一点必须注意：jdk动态代理的应用前提，必须是目标类基于统一的接口。如果没有上述前提，jdk动态代理不能应用。
由此可以看出，jdk动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。。


一、什么是ASM

      首先看下官方中的说明 ASM a very small and fast Java bytecode manipulation framework。

      ASM是一个JAVA字节码分析、创建和修改的开源应用框架。它可以动态生成二进制格式的stub类或其他代理类，
      或者在类被JAVA虚拟机装入内存之前，动态修改类。在ASM中提供了诸多的API用于对类的内容进行字节码操作的方法。
      与传统的BCEL和SERL不同，在ASM中提供了更为优雅和灵活的操作字节码的方式。
  ASM相当小巧，并且它有更高的执行效率，是BCEL的7倍，SERP的11倍以上(摘自网络，具体没有测试)。
  目前ASM已被广泛的开源应用架构所使用，例如：Spring、Hibernate等。

二、ASM能做什么

      我们都知道，一般情况下，Class文件是通过javac编译器产生的，
      然后通过类加载器加载到虚拟机内，再通过执行引擎去执行。
      
      现在我们可以通过ASM的API直接生成符合Java虚拟机规范的Class字节流，
      这样，ASM做的事情一定程度上正是javac解释器做的工作。

     可以说ASM分析一个类、从字节码角度创建一个类、修改一个已经被编译过的类文件。

     那么，我们就可以通过ASM来实现诸如代码生成，代码混淆，代码转换等等以字节码为操作目标的工作